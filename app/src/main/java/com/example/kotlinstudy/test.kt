package com.example.kotlinstudy

// 비트연산
// 정수형 변수를 10진법으로 연산하는 대신 2진법인 비트단위로 연산할 수 있는 기능
// 실무에서는 비트연산은 거의 계산에는 사용하지 않음
// (2진법을 이용한 연산 최적화가 필요하다면 컴파일러의 기능을 사용하는 경우가 대부분)
// 정수형의 값을 비트단위로 나누어 데이터를 좀 더 작은 단위로 담아 경제성을 높이기 위한 용도로 사용

// 32비트인 int 타입 안에 32개의 0과 1로된 서로 다른 값을 넣는다거나
// 앞에 5비트와 뒤에 27비트에 서로다른 값을 넣는식으로 변수하나에 여러개의 값을담아 사용 ㄱㄴ

// 비트연산을 사용하는 부하도 무시할수 ㄴㄴ
// -> 주로 플래그값(여러개의 상태값을 0과 1로 담는방법) 처리하거나
// 네트워크상에서 프로토콜의 데이터 양을 줄이기위해 자주 사용

// 정수형변수의 비트연산할땐 좌측으로갈수록 상위비트, 우측으로갈수록 하위비트
// 코틀린에서는 모든 정수형이 부호를 포함하므로 최상위비트를 부호비트(0이면 양수, 1이면 음수)


// bitwise shift operators 연산자
// shl - 부호비트를 제외한 모든 비트를 좌측으로 밀어주는 기능 (shift left)
// shr - 부호비트를 제외한 모든 비트를 우측으로 밀어주는 기능 (shift right)
// ushr - 부호비트를 포함하여 모든 비트를 우측으로 밀어주는 기능 (unsigned shift right)

// bitwise operators 연산자
// and - 비트가 둘다 1인 자리만 1로 반환 (1010 and 0110 -> 0010)
// or - 비트가 둘 중 하나하도 1인 자리는 1로 반환 (1010 or 0110 -> 1110)
// xor - 비트가 같은 자리는 0, 다른 자리는 1로 반환 (1010 xor 0110 -> 1100)

// and 연산자는 특성을 이용하여 두가지 기능으로 사용함
// 1. 비트를 확인하는 용도 - 원하는 위치에만 1을 넣어 비교해보면 1인지 0인지 확인ㄱㄴ
// 2. 비트의 clear 연산 - and 연산자를 사용하여 비트를 0으로 만들고 싶은 부분에만 0을 넣어 연산해주면 1인 부분만 남고 나머지는 모두 clear 됨

// or 연산자는 비트의 set 연산 (비트 값을 1로 설정하고 싶을 때) 사용
// 비트를 1로 만들고 싶은 부분에만 1을 넣어 연산해주면 0인 부분은 그대로 남고 1인부분만 set

// xor 연산자는 비교할 두 값이 비트별로 동일한지 확인하는데 사용

// inv() 함수
// 비트를 모두 반전시키는 역할을 함 (0은 1로, 1은 0으로)

fun main() {

    var bitData: Int = 0b10000

    bitData = bitData or (1 shl 2)
    println(bitData.toString(2))

    var result = bitData and (1 shl 4)
    println(result.toString(2))

    println(result shr 4)

    bitData = bitData and (1 shl 4).inv()
    println(bitData.toString())

    println((bitData xor (0b10100)).toString(2))

}
// 비트연산은 아주 제한적인 경우에 사용되지만 반드시 알아야할 중요한연산